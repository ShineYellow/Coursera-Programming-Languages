<meta charset="utf-8"/>
<co-content>
 <p>
  This module of the course, the last module in Part A, covers 4 overall topics:
 </p>
 <ol bullettype="numbers">
  <li>
   <p>
    The main idea behind how ML does
    <em>
     type inference
    </em>
    , including inferring polymorphic types.
   </p>
  </li>
  <li>
   <p>
    How to do
    <em>
     mutual recursion
    </em>
    in ML.
   </p>
  </li>
  <li>
   <p>
    ML's
    <em>
     module system
    </em>
    , and how it (and module systems in general) provide the absolutely fundamental ideas of
    <em>
     encapsulation
    </em>
    and
    <em>
     abstraction
    </em>
    .
   </p>
  </li>
  <li>
   <p>
    A substantial discussion of what it means for two functions to be
    <em>
     equivalent
    </em>
    and how functional programming, particularly the lack of mutation, allows for more things to be equivalent.
   </p>
  </li>
 </ol>
 <p>
  Type inference is an important topic so that ML does not seem magical -- although we do not discuss all aspect of ML type inference, we will do enough to convince you that the way ML decides if code type-checks is a well-defined algorithm with precise constraints even though programmers do not need to write down explicit types.
 </p>
 <p>
  Mutual recursion is a minor topic, but it seems worthwhile not to give the misimpression that two ML functions cannot call each other.
 </p>
 <p>
  Modularity is one of the most important techniques for software development and ML's module system is an elegant and often under-appreciated approach to enforcing modularity.  We will particularly focus on how a module can
  <em>
   hide
  </em>
  the definition of a type from clients and how this can enforce invariants.
 </p>
 <p>
  Equivalence is more related to the module-system topic than it may initially seems: Modularity makes more things equivalent by hiding implementation details so clients cannot assume them.  Equivalence is an essential concept in software -- if you have ever said, "here is a different way to
  <em>
   do the same thing
  </em>
  ", then you were (informally) reasoning about equivalence.  Our study will aim to make "what it means to do the same thing" more precise.
 </p>
 <p>
  There is no programming assignment with this module -- instead there is an exam (a "quiz") covering and completing Part A.  A separate reading preceding the exam and a practice exam provides all the information about that.  We hope and intend that studying for the exam will be a way to synthesize and re-enforce everything (and it has been a lot!) you have learned in Part A of the course.  Note that before we split the course into 3 parts, this exam was called a "midterm", so there may remain references in the lectures or other materials to a "midterm"... this means the "Part A Exam" in this module.
 </p>
 <p>
  Lastly, we have a short wrap-up video for Part A and looking ahead to Part B and Part C.  Congratulations on (after this module) reaching a major milestone in your study of programming languages!
 </p>
</co-content>
<style>
 body {
    padding: 50px 85px 50px 85px;
}

table th, table td {
    border: 1px solid #e0e0e0;
    padding: 5px 20px;
    text-align: left;
}
input {
    margin: 10px;
}
}
th {
    font-weight: bold;
}
td, th {
    display: table-cell;
    vertical-align: inherit;
}
img {
    height: auto;
    max-width: 100%;
}
pre {
    display: block;
    margin: 20px;
    background: #424242;
    color: #fff;
    font-size: 13px;
    white-space: pre-wrap;
    padding: 9.5px;
    margin: 0 0 10px;
    border: 1px solid #ccc;
}
</style>
<script async="" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
</script>
<script type="text/x-mathjax-config">
 MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$$','$$'], ['$','$'] ],
      displayMath: [ ["\\[","\\]"] ],
      processEscapes: true
    }
  });
</script>
